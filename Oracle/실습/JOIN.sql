-- ID, NAME, JOB, SAL 검색 => JOIN
-- SQL 조인 방식
SELECT *
FROM TEST1, TEST2
WHERE TEST1.ID = TEST2.ID;  -- 동등조인

-- 테이블 이름에 별칭
SELECT *
FROM TEST1 T1, TEST2 T2
WHERE T1.ID = T2.ID;

-- OUTER JOIN: 기본은 동등조인이면서 한쪽의 모든 레코드를 검색할 때
-- 1. LEFT OUTER JOIN
SELECT *
FROM TEST1 T1, TEST2 T2
WHERE T1.ID = T2.ID(+);

-- 2. RIGHT OUTER JOIN
SELECT *
FROM TEST1 T1, TEST2 T2
WHERE T1.ID(+) = T2.ID;

-- 3. FULL OUTER JOIN: SQL조인 방식에서는 지원하지 않는다.
SELECT *
FROM TEST1 T1, TEST2 T2
WHERE T1.ID(+) = T2.ID(+); -- 작동하지 않는다.

-- ANSI 조인 방식
SELECT *
FROM TEST1 INNER JOIN TEST2 -- INNER 단어 생략 가능
ON TEST1.ID = TEST2.ID;

-- 테이블 이름에 별칭
SELECT *
FROM TEST1 T1 JOIN TEST2 T2 -- INNER 단어 생략 가능
ON T1.ID = T2.ID;

-- USING절: JOIN 조건의 대상이 되는 컬럼의 이름이 동일할 때 USING 사용
-- ON 대신에 사용한다.
SELECT ID, NAME, JOB, SAL
FROM TEST1 JOIN TEST2
USING(ID); -- 컬럼 이름이 같아야 한다.

-- NATURAL JOIN: JOIN을 하는 테이블에서 같은 컬럼명 및 타입을 갖는 컬럼을 기준으로 모두 JOIN을 해준다.
SELECT *
FROM TEST1 NATURAL JOIN TEST2;

-- OUTER JOIN
-- 1. LEFT OUTER JOIN
SELECT ID, NAME, ADDR, JOB, SAL
FROM TEST1 LEFT JOIN TEST2
USING(ID);

-- 2. RIGHT OUTER JOIN
SELECT ID, NAME, ADDR, JOB, SAL
FROM TEST1 RIGHT JOIN TEST2
USING(ID);

-- 3. FULL OUTER JOIN
SELECT ID, NAME, ADDR, JOB, SAL
FROM TEST1 FULL JOIN TEST2
USING(ID);

-- 3개의 테이블 조인
CREATE TABLE TEST3(
    CODE CHAR(3) PRIMARY KEY REFERENCES TEST2(CODE), -- PK + FK
    MANAGER_NAME VARCHAR2(30),
    PHONE VARCHAR2(30)
);

INSERT INTO TEST3 VALUES('A01', '유재석', '111-1111');
INSERT INTO TEST3 VALUES('A02', '송중기', '222-2222');
INSERT INTO TEST3 VALUES('A03', '이효리', '333-3333');

SELECT * FROM TEST1;
SELECT * FROM TEST2;
SELECT * FROM TEST3;

-- ID, NAME, ADDR, JOB, SAL, MANAGER_NAME, PHONE 검색
-- SQL 조인 방식
SELECT TEST1.ID, NAME, ADDR, JOB, SAL, MANAGER_NAME, PHONE
FROM TEST1, TEST2, TEST3
WHERE TEST1.ID = TEST2.ID AND TEST2.CODE = TEST3.CODE;


-- ANSI 조인 방식
SELECT ID, NAME, ADDR, JOB, SAL, MANAGER_NAME, PHONE
FROM TEST1 JOIN TEST2
USING(ID) JOIN TEST3 USING(CODE); -- USING으로 ID를 묶고, CODE를 묶는다. 


-- JOIN에 조건 넣기 
-- SAL가 300이상인 레코드 JOIN
SELECT TEST1.ID, NAME, ADDR, JOB, SAL, MANAGER_NAME, PHONE
FROM TEST1, TEST2, TEST3
WHERE TEST1.ID = TEST2.ID AND TEST2.CODE = TEST3.CODE AND SAL >= 300;

-- USING.VER
-- USING에 다른 조건 사용 불가능
SELECT ID, NAME, ADDR, JOB, SAL, MANAGER_NAME, PHONE
FROM TEST1 JOIN TEST2
USING(ID) JOIN TEST3 USING(CODE)
WHERE SAL > = 300;


SELECT T1.ID, NAME, JOB, SAL
FROM TEST1 T1 JOIN TEST2 T2 
ON T1.ID = T2.ID AND SAL >= 300;

-- SUBQUERY
--EMP테이블에서 평균 급여보다 더 많이 받는 사원 검색
 -- 1. 평균 급여를 구한다.
    SELECT AVG(SAL) FROM EMP;

 -- 2. 1의 결과를 조건으로 사용한다.
    SELECT * 
    FROM EMP
    WHERE SAL > (SELECT AVG(SAL) FROM EMP);

      
-- JOB에 'A'문자열이 들어간 사원의 부서와 같은 곳에서 근무하는 사원의 부서이름 검색하고 싶다. 
  SELECT DNAME
  FROM DEPT
  WHERE DEPTNO IN (SELECT DISTINCT DEPTNO
                  FROM EMP
                  WHERE JOB LIKE '%A%'); -- 결과값이 하나 이상이기 때문에 IN, ANY, ALL
  
     
 -- 부서번호가 30인 사원들이 급여중에서 가장 많이 받는 사원보다 더 많이 받는 사원정보를 검색하고 싶다. 
  SELECT *
  FROM EMP
  WHERE SAL > (SELECT MAX(SAL)
               FROM EMP
               WHERE DEPTNO = 30);

  

SELECT * FROM COPY_EMP;
DELETE FROM COPY_EMP;
COMMIT;
-- SUBQUERY를 INSERT
INSERT INTO COPY_EMP (SELECT * FROM EMP WHERE SAL > 2000); -- 다른 테이블의 데이터를 가져와서 삽입한다.
-- 다른 테이블로부터 특정한 컬럼만 가져와서 INSERT한다.
INSERT INTO COPY_EMP(EMPNO, ENAME, JOB, SAL)(SELECT EMPNO, ENAME, JOB, SAL FROM EMP WHERE DEPTNO=20);

--SUBQUERY를 UPDATE
   --EX) EMP테이블에서 EMPNO 7900인 사원의 JOB, MGR, DEPTNO로 SUB_EMP테이블의 7566의 사원의 정보로 수정해보자.
UPDATE COPY_EMP
SET JOB=(SELECT JOB FROM EMP WHERE EMPNO=7900), 
    MGR=(SELECT MGR FROM EMP WHERE EMPNO=7900), 
    DEPTNO=(SELECT DEPTNO FROM EMP WHERE EMPNO=7900)
WHERE EMPNO = 7566; 


UPDATE COPY_EMP
SET (JOB, MGR, DEPTNO) = (SELECT JOB, MGR, DEPTNO FROM EMP WHERE EMPNO=7900)
WHERE EMPNO = 7566;
--SUBQUERY를 DELETE
   --EX) EMP테이블이 평균 급여를 조건으로 사용해서 평균급여보다 많이 받는 사원들을 삭제한다. 
DELETE
FROM COPY_EMP
WHERE SAL < (SELECT AVG(SAL) FROM EMP);

-- 상호관계 서브쿼리
-- 소속부서 평균 급여보다 많은 급여를 받는 사원 출력
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO
FROM EMP E
WHERE SAL > ( SELECT AVG(SAL)
              FROM EMP
              WHERE DEPTNO=E.DEPTNO)
ORDER BY DEPTNO;

-- ROWNUM
-- ROWNUM을 대상으로 조건을 만들어보자 .
--1. ROWUM이 3보다 작은 레코드 검색
SELECT ROWNUM, ENAME, JOB, SAL
FROM (SELECT * FROM EMP ORDER BY SAL DESC) 
WHERE ROWNUM < 3;

--2. ROWUM이 3보다 큰 레코드 검색
SELECT ROWNUM, ENAME, JOB, SAL
FROM (SELECT * FROM EMP ORDER BY SAL DESC) 
WHERE ROWNUM > 3; --X

--3. ROWUM이 5 ~ 7 사이 레코드 검색
SELECT ROWNUM, ENAME, JOB, SAL
FROM (SELECT * FROM EMP ORDER BY SAL DESC) 
WHERE ROWNUM BETWEEN 5 AND 7 ; --X



-- NON-EQUI JOIN

SELECT * FROM SALGRADE;

-- EMP테이블에서 사원의 정보 + 급여등급 검색
SELECT EMPNO, ENAME, JOB, SAL, GRADE
FROM EMP JOIN SALGRADE
ON SAL BETWEEN LOSAL AND HISAL
ORDER BY SAL;

-- SELF JOIN + 자기자신테이블을 2개로 만들어 JOIN (재귀적 관계)
SELECT *
FROM EMP;

-- EX) "SMITH 사원의 관리자는 FORD입니다." 출력
SELECT E1.ENAME ||' 사원의 관리자는 '|| E2.ENAME
FROM EMP E1 JOIN EMP E2 -- (E1은 사원테이블, E2는 관리자테이블) SELF JOIN은 별칭 필수
ON E1.MGR = E2.EMPNO;