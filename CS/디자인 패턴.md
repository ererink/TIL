# 디자인 패턴 Design Pattern

## 디자인 패턴이란?

**세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결방식** 또는 예제이다. 

즉, SW를 설계할 때 특정 맥락에서 자주 발생하는 **고질적인 문제**들이 발생하였을 때 **재사용**할 수 있도록 만들어 놓은 해결책이다. 

- 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성
- **'바퀴를 다시 발명하지 마라', 'Don't reinvent the wheel'**
  - 문제가 발생하면 새로 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참고하는 것이 더 효율적
- 한 패턴에 변형을 가하거나 특정 요구사항을 반영하면 유사한 형태의 다른 패턴으로 변화
- **GoF(Gang of Four) in 1995**
  - 처음으로 디자인 패턴을 구체화 및 체계화함
  - 가장 일반적인 사례에 적용될 수 있는 패턴들을 분류함으로써 지금도 소프트웨어 공학이나 현업에서 많이 사용되고 있음
- 생성패턴 5개, 구조 패턴 7개, 행위 패턴 11개로 총 23개의 패턴으로 구성



### 장단점

**장점**

- 구조 파악이 용이하다.
  - 범용적인 코딩 스타일
- 객체지향 설계 및 구현의 생산성을 높이는 데 적합
- 개발 시간과 비용 절약
  - 재사용으로 인해
- 개발자 간의 원활한 의사소통 가능
- 설계 변경 요청에 대한 유연한 대처 가능

**단점**

- 초기 투자 비용 부담
  - 요구 사항을 직관적으로 구현하는 것이 아닌 디자인 패턴에 맞게 구현해야 하기 때문에 초기에 노력과 시간이 비용 부담으로 작용할 수 있음
- 객체지향 기반의 애플리케이션 개발만 적합함



![img](https://blog.kakaocdn.net/dn/bcrXCi/btrVz991ogG/943noPDaaFk6gq9XVVfCpk/img.png)

##  

## 생성 패턴 Creational Pattern

객체의 생성과 참조 과정을 **캡슐화**하여 프로그램 **구조에 영향을 크게 받지 않도록** 하여 프로그램에 유연성을 준다.

> 객체의 생성 방식 결정

| **추상 팩토리** **Abstract Factory** | • 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현한다. • 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능하다. |
| ------------------------------------ | ------------------------------------------------------------ |
| **빌더** **Builder**                 | • 인스턴스를 건축하듯이 조합하여 객체를 생성한다.            |
| **팩토리 메소드** **Factory Method** | • 객체 생성을 서브 클래스에서 처리하도록 분리하여 **캡슐화**한다. • 상위 클래스에서 인터페이스만 정의하고, **실제 생성은 서브 클래스**가 담당한다. • **가상 생성자**(Virtual Constructor) 패턴이라고도 한다. |
| **프로토타입** **Prototype**         | • 원본 객체를 복제하는 방법으로 객체를 생성한다. • 비용이 큰 경우 주로 사용한다. |
| **싱글톤** **Singleton**             | • 하나의 객체 생성 시 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수 없다. • 클래스 내에서 **인스턴스가 하나뿐임을 보장**하여 **불필요한 메모리 낭비를 최소화**할 수 있다. |



## 구조 패턴 Structural Pattern

객체들을 조합하여 **더 큰 구조**로 만들 수 있게 하는 패턴이다. 

> 객체간의 관계를 조직

| **어댑터** **Adapter**         | • 다른 클래스가 이용할 수 있도록 변환한다. (for 호환성이 없는 클래스들) • 인터페이스가 일치하지 않을 때 이용 |
| ------------------------------ | ------------------------------------------------------------ |
| **브리지** **Bridge**          | • 서로가 독립적으로 확장할 수 있도록 구성한다. • 기능과 구현을 두 개의 별도 클래스로 구현한다. |
| **컴포지트** **Composite**     | • 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용한다. • 객체들을 **트리 구조**로 구성하여 복합 객체 안에 복합 객체가 포함되는 구조로 구현 가능하다. |
| **데코레이터** **Decorator**   | • 객체 간의 결합을 통해 능동적으로 기능을 확장할 수 있다. • 객체에 부가적인 기능을 추가하기 위해 다른 객체를 덧붙이는 방식으로 구현한다. |
| **퍼사드** **Facade**          | • 복잡한 서브 클래스들을 피해 더 상위 인터페이스를 구성함으로써 서브 클래들의 기능을 간편하게 사용한다. • 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요하다. |
| **플라이웨이트** **Flyweight** | • 가능한 공유해서 사용함으로써 메모리를 절약한다. • 다수의 유사 객체를 생성하거나 조작할 때 유용하다. |
| **프록시** **Proxy**           | • 객체 사이에서 인터페이스 역할을 수행한다. • 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 사용한다. |



## 행위 패턴 Behavioral Pattern

객체들이 서로 **상호작용**하는 방법이나 **책임 분배 방법**을 정의한다.

하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화할 수 있도록 도와준다.

> 객체의 행위를 조직, 관리, 연합

| **책임 연쇄** **Chain of Responsibility** | • 한 객체가 요청을 처리하지 못하면 다른 객체로 넘어간다. • 요청을 처리하는 각 객체들이 고리로 묶여있어 요청이 해결될 때 까지 고리를 따라 책임이 넘어간다. |
| ----------------------------------------- | ------------------------------------------------------------ |
| **커맨드** **Command**                    | • 요청을 캡슐화하여 재이용하거나 취소할 수 있도록 정보를 저장하거나 로그에 남긴다. • 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화한다. |
| **인터프리터** **Interpreter**            | • 문법 표현을 정의한다. • SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용한다. |
| **반복자** **Iterator**                   | • 자료구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 한다. • 내부 표현 방법의 노출 없이 순차적인 접근이 가능하다. |
| **중재자** **Mediator**                   | • 복잡한 상호작용을 캡슐화하여 객체로 정의한다. • 객체들 간의 의존성을 줄여 결합도를 감소시킨다. • 객체 간의 통제와 지시의 역할을 수행한다. |
| **메멘토** **Memento**                    | • 객체 내부 상태를 객체화함으로써 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공한다. • Ctrl + Z 같은 되돌리기 기능 개발할 때 주로 사용한다. |
| **옵서버** **Observer**                   | • 객체의 상태가 변화하면 상속되어 있는 다른 객체에게 변화된 상태를 전달한다. • 분산된 시스템 간에 이벤트 생성 및 발행, 수신 시 주로 사용한다. |
| **상태** **State**                        | • 객체 상태에 따라 동일한 동작을 다르게 처리할 때 사용한다. • 객체 상태를 캡슐화하고 참조하는 방식으로 처리한다. |
| **전략** **Strategy**                     | • 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있도록 정의한다. • 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있고, 클라이언트에 영향 없이 알고리즘 변경이 가능하다. |
| **템플릿 메소드** **Template Method**     | • 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화한다. • 공통된 내용(유사한 서브 클래스를 묶어)을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 한다. |
| **방문자** **Visitor**                    | • 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성한다. • 분리된 처리 기능은 각 클래스에서 방문하여 수행한다. |